<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="SportGlobe">
<meta name="theme-color" content="#06060f">
<link rel="manifest" href="/manifest.json">
<title>SportGlobe</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600;700;800&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #06060f; overflow: hidden; font-family: 'Space Grotesk', sans-serif; color: #fff; width: 100vw; height: 100vh; }
  canvas#globe { position: absolute; inset: 0; cursor: grab; }
  canvas#globe.dragging { cursor: grabbing; }
  #ui { position: absolute; inset: 0; pointer-events: none; }
  #ui > * { pointer-events: auto; }
  #header { position: absolute; top: 0; left: 0; right: 0; padding: 14px 20px; background: linear-gradient(to bottom, rgba(6,6,15,0.95), transparent); display: flex; align-items: center; justify-content: space-between; z-index: 10; }
  #header .logo { display: flex; align-items: center; gap: 10px; }
  #header .logo h1 { font-size: 19px; font-weight: 800; letter-spacing: -0.5px; }
  #header .logo .sub { font-size: 9px; color: rgba(255,255,255,0.3); font-family: 'JetBrains Mono', monospace; letter-spacing: 2px; text-transform: uppercase; }
  .live-badge { display: flex; align-items: center; gap: 8px; background: rgba(239,68,68,0.15); border: 1px solid rgba(239,68,68,0.25); padding: 5px 12px; border-radius: 20px; }
  .live-dot { width: 7px; height: 7px; border-radius: 50%; background: #EF4444; box-shadow: 0 0 8px #EF4444; animation: livePulse 1.5s infinite; }
  .live-count { color: #EF4444; font-size: 11px; font-weight: 700; font-family: 'JetBrains Mono', monospace; }
  #filters { position: absolute; top: 62px; left: 0; right: 0; display: flex; gap: 5px; padding: 0 20px; overflow-x: auto; z-index: 10; scrollbar-width: none; }
  #filters::-webkit-scrollbar { display: none; }
  .filter-btn { display: flex; align-items: center; gap: 5px; padding: 5px 12px; border-radius: 18px; border: 1px solid rgba(255,255,255,0.07); background: rgba(255,255,255,0.03); color: rgba(255,255,255,0.45); font-size: 11px; font-weight: 600; cursor: pointer; white-space: nowrap; font-family: 'Space Grotesk', sans-serif; transition: all 0.2s; }
  .filter-btn.active { border-color: rgba(255,255,255,0.3); background: rgba(255,255,255,0.12); color: #fff; }
  #zoom-controls { position: absolute; right: 16px; display: flex; flex-direction: column; gap: 6px; z-index: 10; transition: bottom 0.3s; }
  .zoom-btn { width: 34px; height: 34px; border-radius: 8px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.1); color: #fff; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center; }
  #ticker { position: absolute; left: 14px; right: 14px; display: flex; gap: 7px; overflow-x: auto; z-index: 10; padding: 4px 0; transition: bottom 0.3s; scrollbar-width: none; }
  #ticker::-webkit-scrollbar { display: none; }
  .ticker-item { display: flex; align-items: center; gap: 7px; padding: 7px 12px; border-radius: 10px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.06); color: #fff; cursor: pointer; white-space: nowrap; min-width: fit-content; }
  .ticker-item.selected { border-color: var(--tc); background: color-mix(in srgb, var(--tc) 12%, transparent); }
  #card { position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(to top, rgba(0,0,0,0.97), rgba(10,10,20,0.95)); backdrop-filter: blur(20px); padding: 20px 24px 24px; z-index: 20; transform: translateY(100%); transition: transform 0.3s ease-out; }
  #card.open { transform: translateY(0); }
  #card .close-btn { position: absolute; top: 12px; right: 16px; background: rgba(255,255,255,0.1); border: none; color: #fff; font-size: 18px; cursor: pointer; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; }
  .stream-btn { width: 100%; padding: 14px; border: none; border-radius: 10px; color: #fff; font-size: 15px; font-weight: 700; cursor: pointer; font-family: 'Space Grotesk', sans-serif; }
  #stream-overlay { position: absolute; inset: 0; background: #000; z-index: 30; display: none; flex-direction: column; }
  #stream-overlay.open { display: flex; }
  @keyframes livePulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
</style>
</head>
<body>
<canvas id="globe"></canvas>
<div id="ui">
  <div id="header">
    <div class="logo"><span style="font-size:26px">üåç</span><div><h1>SportGlobe</h1><div class="sub">Live Sports Worldwide</div></div></div>
    <div class="live-badge"><span class="live-dot"></span><span class="live-count" id="liveCount">Loading...</span></div>
  </div>
  <div id="statusBar" style="position:absolute;top:44px;right:20px;font-size:9px;color:rgba(255,255,255,0.25);font-family:'JetBrains Mono',monospace;z-index:10;text-align:right"></div>
  <div id="filters"></div>
  <div id="zoom-controls" style="bottom:80px">
    <button class="zoom-btn" onclick="zoomIn()">+</button>
    <button class="zoom-btn" onclick="zoomOut()">‚àí</button>
  </div>
  <div id="ticker" style="bottom:14px"></div>
  <div id="card">
    <button class="close-btn" onclick="closeCard()">‚úï</button>
    <div id="cardContent"></div>
  </div>
  <div id="stream-overlay">
    <div id="streamHeader" style="display:flex;align-items:center;justify-content:space-between;padding:12px 20px;background:rgba(20,20,30,0.95)"></div>
    <div style="flex:1;display:flex;align-items:center;justify-content:center;background:radial-gradient(ellipse at center,#1a1a2e,#000 70%)">
      <div style="text-align:center" id="streamBody"></div>
    </div>
  </div>
</div>

<script>
// ‚Äî‚Äî‚Äî DATA ‚Äî‚Äî‚Äî
let SPORTS = []; // Populated by live API
const ICONS = { basketball:"üèÄ", soccer:"‚öΩ", hockey:"üèí", cricket:"üèè", rugby:"üèâ", tennis:"üéæ", aussie_rules:"üèà", mma:"ü•ä", baseball:"‚öæ" };
const FILTERS = [{k:"all",l:"All",i:"üåç"},{k:"soccer",l:"Soccer",i:"‚öΩ"},{k:"basketball",l:"Basketball",i:"üèÄ"},{k:"hockey",l:"Hockey",i:"üèí"},{k:"baseball",l:"Baseball",i:"‚öæ"},{k:"rugby",l:"Rugby",i:"üèâ"}];

// Sport colors
const SPORT_COLORS = { soccer:"#8B5CF6", basketball:"#F97316", hockey:"#06B6D4", baseball:"#A855F7", rugby:"#EF4444" };

// ‚Äî‚Äî‚Äî VENUE GEOCODING DATABASE ‚Äî‚Äî‚Äî
// Major venue cities ‚Üí coordinates. When API returns a venue/city, we look up coords here.
// Falls back to country capital if venue unknown.
const CITY_COORDS = {
  // England
  "london":[51.505,-0.09],"manchester":[53.483,-2.244],"liverpool":[53.408,-2.991],"birmingham":[52.486,-1.890],"leeds":[53.801,-1.548],"newcastle":[54.978,-1.617],"sheffield":[53.381,-1.470],"nottingham":[52.950,-1.150],"leicester":[52.634,-1.131],"brighton":[50.861,-0.083],"wolverhampton":[52.590,-2.130],"southampton":[50.906,-1.404],"bournemouth":[50.735,-1.838],"west ham":[51.532,-0.039],
  // Spain
  "madrid":[40.453,-3.688],"barcelona":[41.381,2.123],"seville":[37.384,-5.970],"valencia":[39.475,-0.358],"bilbao":[43.264,-2.949],"vigo":[42.212,-8.739],
  // Italy
  "milan":[45.478,9.124],"rome":[41.934,12.455],"turin":[45.109,7.641],"naples":[40.828,14.193],"florence":[43.781,11.282],"genoa":[44.416,8.952],"bergamo":[45.709,9.681],
  // Germany
  "munich":[48.219,11.625],"dortmund":[51.493,7.452],"berlin":[52.514,13.239],"frankfurt":[50.069,8.645],"leipzig":[51.346,12.348],"leverkusen":[51.038,7.002],"stuttgart":[48.792,9.232],"gelsenkirchen":[51.554,7.068],
  // France
  "paris":[48.841,2.253],"marseille":[43.270,5.396],"lyon":[45.765,4.982],"lille":[50.612,3.130],"nice":[43.705,7.192],"monaco":[43.727,7.416],"bordeaux":[44.850,-0.561],"strasbourg":[48.560,7.620],"nantes":[47.256,-1.525],
  // USA
  "new york":[40.751,-73.994],"brooklyn":[40.683,-73.975],"los angeles":[34.043,-118.267],"chicago":[41.881,-87.674],"boston":[42.366,-71.062],"philadelphia":[39.901,-75.172],"houston":[29.685,-95.411],"dallas":[32.790,-96.810],"san francisco":[37.770,-122.387],"denver":[39.749,-104.999],"miami":[25.781,-80.187],"atlanta":[33.757,-84.396],"phoenix":[33.446,-112.071],"detroit":[42.341,-83.055],"minneapolis":[44.980,-93.276],"seattle":[47.622,-122.354],"milwaukee":[43.044,-87.917],"cleveland":[41.496,-81.688],"indianapolis":[39.764,-86.156],"orlando":[28.539,-81.384],"charlotte":[35.225,-80.839],"sacramento":[38.580,-121.500],"san antonio":[29.427,-98.438],"memphis":[35.138,-90.051],"portland":[45.532,-122.667],"oklahoma city":[35.463,-97.515],"washington":[38.898,-77.021],"new orleans":[29.949,-90.082],"salt lake city":[40.768,-111.901],"las vegas":[36.170,-115.140],"tampa":[27.943,-82.452],"pittsburgh":[40.439,-79.989],"st. louis":[38.627,-90.200],"kansas city":[39.049,-94.584],"cincinnati":[39.097,-84.516],"raleigh":[35.803,-78.722],"nashville":[36.159,-86.779],"columbus":[39.969,-82.999],"buffalo":[42.875,-78.876],"anaheim":[33.808,-117.877],"san jose":[37.333,-121.901],"oakland":[37.751,-122.203],"arlington":[32.751,-97.083],"baltimore":[39.284,-76.622],"san diego":[32.707,-117.157],
  // Canada
  "toronto":[43.644,-79.379],"montreal":[45.496,-73.570],"vancouver":[49.278,-123.109],"ottawa":[45.297,-75.928],"calgary":[51.037,-114.052],"edmonton":[53.547,-113.498],"winnipeg":[49.893,-97.143],
  // Brazil
  "rio de janeiro":[-22.912,-43.230],"sao paulo":[-23.547,-46.635],"belo horizonte":[-19.924,-43.945],"porto alegre":[-30.034,-51.217],
  // Argentina
  "buenos aires":[-34.614,-58.410],
  // Mexico
  "mexico city":[19.303,-99.150],"guadalajara":[20.702,-103.389],"monterrey":[25.670,-100.315],
  // Asia
  "tokyo":[35.690,139.692],"osaka":[34.669,135.432],"seoul":[37.568,126.978],"beijing":[39.907,116.391],"shanghai":[31.224,121.469],"mumbai":[18.939,72.836],"delhi":[28.613,77.230],"kolkata":[22.565,88.350],"chennai":[13.083,80.270],"bangalore":[12.978,77.590],"melbourne":[-37.814,144.963],"sydney":[-33.870,151.207],"perth":[-31.953,115.861],"brisbane":[-27.470,153.023],"dubai":[25.228,55.280],
  // Africa
  "cairo":[30.044,31.236],"johannesburg":[-26.205,28.050],"cape town":[-33.925,18.424],"lagos":[6.455,3.384],"nairobi":[-1.292,36.822],
  // Other
  "amsterdam":[52.314,4.942],"lisbon":[38.753,-9.185],"porto":[41.161,-8.583],"brussels":[50.835,4.298],"vienna":[48.209,16.363],"zurich":[47.383,8.533],"istanbul":[41.009,28.951],"moscow":[55.816,37.555],"stockholm":[59.345,18.075],"copenhagen":[55.604,12.452],"oslo":[59.913,10.752],"helsinki":[60.188,24.952],"warsaw":[52.221,20.976],"prague":[50.083,14.421],"budapest":[47.503,19.074],"athens":[37.976,23.736],"bucharest":[44.437,26.089],"belgrade":[44.789,20.473],"zagreb":[45.808,15.979],
};

// Country fallback coords
const COUNTRY_COORDS = {
  "england":[51.505,-0.09],"spain":[40.453,-3.688],"italy":[41.934,12.455],"germany":[50.069,8.645],"france":[48.841,2.253],"portugal":[38.753,-9.185],"netherlands":[52.314,4.942],"belgium":[50.835,4.298],"turkey":[41.009,28.951],"scotland":[55.953,-3.188],"usa":[39.8,-98.6],"canada":[45.4,-75.7],"brazil":[-15.793,-47.883],"argentina":[-34.614,-58.410],"mexico":[19.432,-99.133],"japan":[35.690,139.692],"south-korea":[37.568,126.978],"china":[39.907,116.391],"australia":[-33.870,151.207],"india":[28.613,77.230],"russia":[55.816,37.555],
};

function geocode(venue, city, country) {
  // Try city match
  if (city) {
    const c = city.toLowerCase().trim();
    if (CITY_COORDS[c]) return CITY_COORDS[c];
    // Partial match
    for (const [k, v] of Object.entries(CITY_COORDS)) {
      if (c.includes(k) || k.includes(c)) return v;
    }
  }
  // Try venue name for city clues
  if (venue) {
    const v = venue.toLowerCase();
    for (const [k, coords] of Object.entries(CITY_COORDS)) {
      if (v.includes(k)) return coords;
    }
  }
  // Country fallback
  if (country) {
    const cn = country.toLowerCase().replace(/ /g, '-').trim();
    if (COUNTRY_COORDS[cn]) return COUNTRY_COORDS[cn];
    for (const [k, v] of Object.entries(COUNTRY_COORDS)) {
      if (cn.includes(k) || k.includes(cn)) return v;
    }
  }
  return null;
}

// ‚Äî‚Äî‚Äî LIVE DATA FETCHING ‚Äî‚Äî‚Äî
let lastFetch = 0;
let fetchCount = 0;

async function fetchSport(sport) {
  try {
    const res = await fetch(`/api/sports?sport=${sport}`);
    if (!res.ok) return [];
    const data = await res.json();
    const remaining = res.headers.get('X-RateLimit-Remaining');
    if (remaining) document.getElementById('statusBar').textContent = `API: ${remaining} req left today`;
    return data.response || [];
  } catch (e) {
    console.warn(`Failed to fetch ${sport}:`, e);
    return [];
  }
}

function parseFootball(fixtures) {
  return fixtures.map((f, i) => {
    const isLive = f.fixture?.status?.short && ['1H','2H','HT','ET','BT','P'].includes(f.fixture.status.short);
    const isUpcoming = f.fixture?.status?.short === 'NS';
    if (!isLive && !isUpcoming) return null;
    const city = f.fixture?.venue?.city || '';
    const venueName = f.fixture?.venue?.name || '';
    const country = f.league?.country || '';
    const coords = geocode(venueName, city, country);
    if (!coords) return null;
    const elapsed = f.fixture?.status?.elapsed || 0;
    const statusMap = { '1H':'1st Half', '2H':'2nd Half', 'HT':'Half Time', 'ET':'Extra Time', 'BT':'Break', 'P':'Penalties' };
    return {
      id: f.fixture.id,
      sport: 'soccer',
      league: f.league?.name || 'Football',
      home: f.teams?.home?.name || '?',
      away: f.teams?.away?.name || '?',
      venue: venueName, city: city, country: country,
      lat: coords[0], lng: coords[1],
      status: isLive ? 'LIVE' : 'UPCOMING',
      detail: statusMap[f.fixture.status.short] || f.fixture.status.short,
      score: isLive ? `${f.goals?.home ?? 0}-${f.goals?.away ?? 0}` : null,
      time: isLive ? `${elapsed}'` : null,
      startTime: isUpcoming ? new Date(f.fixture.date).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}) : null,
      color: SPORT_COLORS.soccer,
    };
  }).filter(Boolean);
}

function parseBasketball(games) {
  return games.map((g, i) => {
    const status = g.status?.short;
    const isLive = status && ['Q1','Q2','Q3','Q4','OT','BT','HT'].includes(status);
    const isUpcoming = status === 'NS';
    if (!isLive && !isUpcoming) return null;
    const country = g.country?.name || g.league?.name || '';
    const coords = geocode(null, null, country) || (g.league?.name?.includes('NBA') ? [39.8,-98.6] : null);
    if (!coords) return null;
    return {
      id: g.id + 100000,
      sport: 'basketball',
      league: g.league?.name || 'Basketball',
      home: g.teams?.home?.name || '?',
      away: g.teams?.away?.name || '?',
      venue: '', city: '', country: country,
      lat: coords[0] + (Math.random()-0.5)*2, lng: coords[1] + (Math.random()-0.5)*2,
      status: isLive ? 'LIVE' : 'UPCOMING',
      detail: status,
      score: isLive ? `${g.scores?.home?.total ?? 0}-${g.scores?.away?.total ?? 0}` : null,
      time: isLive ? status : null,
      startTime: isUpcoming ? new Date(g.date).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}) : null,
      color: SPORT_COLORS.basketball,
    };
  }).filter(Boolean);
}

function parseHockey(games) {
  return games.map((g, i) => {
    const status = g.status?.short;
    const isLive = status && ['P1','P2','P3','OT','BT'].includes(status);
    const isUpcoming = status === 'NS';
    if (!isLive && !isUpcoming) return null;
    const country = g.country?.name || '';
    const coords = geocode(null, null, country);
    if (!coords) return null;
    const periodMap = {'P1':'1st','P2':'2nd','P3':'3rd','OT':'OT','BT':'Break'};
    return {
      id: g.id + 200000,
      sport: 'hockey',
      league: g.league?.name || 'Hockey',
      home: g.teams?.home?.name || '?',
      away: g.teams?.away?.name || '?',
      venue: '', city: '', country: country,
      lat: coords[0] + (Math.random()-0.5)*2, lng: coords[1] + (Math.random()-0.5)*2,
      status: isLive ? 'LIVE' : 'UPCOMING',
      detail: periodMap[status] || status,
      score: isLive ? `${g.scores?.home ?? 0}-${g.scores?.away ?? 0}` : null,
      time: isLive ? (periodMap[status] || status) : null,
      startTime: isUpcoming ? new Date(g.date).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}) : null,
      color: SPORT_COLORS.hockey,
    };
  }).filter(Boolean);
}

function parseBaseball(games) {
  return games.map((g, i) => {
    const status = g.status?.short;
    const isLive = status && ['I1','I2','I3','I4','I5','I6','I7','I8','I9'].includes(status);
    const isUpcoming = status === 'NS';
    if (!isLive && !isUpcoming) return null;
    const country = g.country?.name || '';
    const coords = geocode(null, null, country);
    if (!coords) return null;
    return {
      id: g.id + 300000,
      sport: 'baseball',
      league: g.league?.name || 'Baseball',
      home: g.teams?.home?.name || '?',
      away: g.teams?.away?.name || '?',
      venue: '', city: '', country: country,
      lat: coords[0] + (Math.random()-0.5)*2, lng: coords[1] + (Math.random()-0.5)*2,
      status: isLive ? 'LIVE' : 'UPCOMING',
      detail: status,
      score: isLive ? `${g.scores?.home?.total ?? 0}-${g.scores?.away?.total ?? 0}` : null,
      time: isLive ? `Inn ${status.replace('I','')}` : null,
      startTime: isUpcoming ? new Date(g.date).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}) : null,
      color: SPORT_COLORS.baseball,
    };
  }).filter(Boolean);
}

async function fetchAllLive() {
  document.getElementById('statusBar').textContent = 'Fetching live data...';
  const [football, basketball, hockey, baseball] = await Promise.all([
    fetchSport('football'),
    fetchSport('basketball'),
    fetchSport('hockey'),
    fetchSport('baseball'),
  ]);
  fetchCount += 4;

  let events = [
    ...parseFootball(football),
    ...parseBasketball(basketball),
    ...parseHockey(hockey),
    ...parseBaseball(baseball),
  ];

  // If no live games, fetch today's schedule
  if (events.filter(e => e.status === 'LIVE').length === 0) {
    document.getElementById('statusBar').textContent = 'No live games ‚Äî fetching today\'s schedule...';
    const [ftToday, bbToday, hkToday, bsToday] = await Promise.all([
      fetchSport('football_today'),
      fetchSport('basketball_today'),
      fetchSport('hockey_today'),
      fetchSport('baseball_today'),
    ]);
    fetchCount += 4;
    events = [
      ...parseFootball(ftToday),
      ...parseBasketball(bbToday),
      ...parseHockey(hkToday),
      ...parseBaseball(bsToday),
    ];
  }

  SPORTS = events;
  lastFetch = Date.now();
  updateLiveCount();
  updateTicker();
  
  const live = events.filter(e => e.status === 'LIVE').length;
  const upcoming = events.filter(e => e.status === 'UPCOMING').length;
  document.getElementById('statusBar').textContent = `${live} live ¬∑ ${upcoming} upcoming ¬∑ ${fetchCount} API calls used`;
}

// ‚Äî‚Äî‚Äî GEO DATA ‚Äî‚Äî‚Äî
let geoPolygons = []; // [{points:[[lng,lat],...], fill, stroke}]
let geoLoaded = false;

// Load TopoJSON world data for realistic borders
async function loadGeoData() {
  try {
    const res = await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json');
    const topo = await res.json();
    // Parse TopoJSON manually (no library needed)
    const geometries = topo.objects.countries.geometries;
    const arcs = topo.arcs;
    const transform = topo.transform;

    function decodeArc(arcIdx) {
      const reverse = arcIdx < 0;
      const idx = reverse ? ~arcIdx : arcIdx;
      const arc = arcs[idx];
      const coords = [];
      let x = 0, y = 0;
      arc.forEach(([dx, dy]) => {
        x += dx; y += dy;
        coords.push([
          x * transform.scale[0] + transform.translate[0],
          y * transform.scale[1] + transform.translate[1]
        ]);
      });
      return reverse ? coords.reverse() : coords;
    }

    function decodeRing(ring) {
      const coords = [];
      ring.forEach(arcIdx => {
        const arcCoords = decodeArc(arcIdx);
        // Skip first point of subsequent arcs to avoid duplicates
        const start = coords.length > 0 ? 1 : 0;
        for (let i = start; i < arcCoords.length; i++) {
          coords.push(arcCoords[i]);
        }
      });
      return coords;
    }

    geometries.forEach(geom => {
      if (geom.type === 'Polygon') {
        geom.arcs.forEach((ring, i) => {
          const coords = decodeRing(ring);
          geoPolygons.push({ points: coords, isHole: i > 0 });
        });
      } else if (geom.type === 'MultiPolygon') {
        geom.arcs.forEach(polygon => {
          polygon.forEach((ring, i) => {
            const coords = decodeRing(ring);
            geoPolygons.push({ points: coords, isHole: i > 0 });
          });
        });
      }
    });
    geoLoaded = true;
  } catch (e) {
    console.warn('GeoJSON load failed, using fallback', e);
  }
}

// ‚Äî‚Äî‚Äî STATE ‚Äî‚Äî‚Äî
let canvas, ctx, W, H;
let rotX = 0.35, rotY = -0.8, targetRotX = 0.35, targetRotY = -0.8;
let zoom = 280, targetZoom = 280;
let dragging = false, lastMX = 0, lastMY = 0, dragDist = 0;
let currentFilter = "all";
let selectedId = null;
let pulseT = 0;
let cardOpen = false;
let stars = null;

// ‚Äî‚Äî‚Äî PROJECTION ‚Äî‚Äî‚Äî
function project(lat, lng) {
  const phi = (90 - lat) * Math.PI / 180;
  const theta = (lng + 180) * Math.PI / 180;
  const x0 = -Math.sin(phi) * Math.cos(theta);
  const y0 = Math.cos(phi);
  const z0 = Math.sin(phi) * Math.sin(theta);
  const cosX = Math.cos(rotX), sinX = Math.sin(rotX);
  const y1 = y0 * cosX - z0 * sinX;
  const z1 = y0 * sinX + z0 * cosX;
  const cosY = Math.cos(rotY), sinY = Math.sin(rotY);
  const x1 = x0 * cosY + z1 * sinY;
  const z2 = -x0 * sinY + z1 * cosY;
  return { x: x1, y: y1, z: z2, sx: W / 2 + x1 * zoom, sy: H / 2 - y1 * zoom, visible: z2 > 0 };
}

// ‚Äî‚Äî‚Äî DRAWING ‚Äî‚Äî‚Äî
function drawStars() {
  if (!stars) {
    stars = [];
    for (let i = 0; i < 200; i++) stars.push({ x: Math.random(), y: Math.random(), r: Math.random() * 1.2 + 0.3, o: Math.random() * 0.3 + 0.05 });
  }
  stars.forEach(s => {
    ctx.beginPath();
    ctx.arc(s.x * W, s.y * H, s.r, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(255,255,255,${s.o})`;
    ctx.fill();
  });
}

function drawGlobe() {
  const cx = W / 2, cy = H / 2;

  // Atmosphere glow
  const ag = ctx.createRadialGradient(cx, cy, zoom * 0.85, cx, cy, zoom * 1.25);
  ag.addColorStop(0, 'rgba(20,60,120,0.07)');
  ag.addColorStop(1, 'transparent');
  ctx.fillStyle = ag;
  ctx.fillRect(0, 0, W, H);

  // Ocean sphere
  ctx.beginPath();
  ctx.arc(cx, cy, zoom, 0, Math.PI * 2);
  const og = ctx.createRadialGradient(cx - zoom * 0.25, cy - zoom * 0.25, zoom * 0.1, cx, cy, zoom);
  og.addColorStop(0, '#101c30');
  og.addColorStop(0.7, '#0a1220');
  og.addColorStop(1, '#060d16');
  ctx.fillStyle = og;
  ctx.fill();

  // Clip to globe for all geo drawing
  ctx.save();
  ctx.beginPath();
  ctx.arc(cx, cy, zoom, 0, Math.PI * 2);
  ctx.clip();

  // Grid lines
  ctx.strokeStyle = 'rgba(25,50,80,0.18)';
  ctx.lineWidth = 0.5;
  for (let lat = -60; lat <= 60; lat += 30) {
    ctx.beginPath();
    let s = false;
    for (let lng = -180; lng <= 180; lng += 2) {
      const p = project(lat, lng);
      if (p.visible) { if (!s) { ctx.moveTo(p.sx, p.sy); s = true; } else ctx.lineTo(p.sx, p.sy); } else s = false;
    }
    ctx.stroke();
  }
  for (let lng = -180; lng < 180; lng += 30) {
    ctx.beginPath();
    let s = false;
    for (let lat = -90; lat <= 90; lat += 2) {
      const p = project(lat, lng);
      if (p.visible) { if (!s) { ctx.moveTo(p.sx, p.sy); s = true; } else ctx.lineTo(p.sx, p.sy); } else s = false;
    }
    ctx.stroke();
  }

  // Countries from GeoJSON
  if (geoLoaded) {
    geoPolygons.forEach(poly => {
      if (poly.isHole) return; // skip holes for now
      const pts = poly.points;
      if (pts.length < 3) return;

      // Quick visibility check: test a few points
      let anyVisible = false;
      for (let i = 0; i < pts.length; i += Math.max(1, Math.floor(pts.length / 8))) {
        const p = project(pts[i][1], pts[i][0]);
        if (p.visible) { anyVisible = true; break; }
      }
      if (!anyVisible) return;

      // Draw filled polygon
      ctx.beginPath();
      let started = false;
      let prevVisible = false;
      for (let i = 0; i < pts.length; i++) {
        const p = project(pts[i][1], pts[i][0]);
        if (p.visible) {
          if (!started || !prevVisible) { ctx.moveTo(p.sx, p.sy); started = true; }
          else ctx.lineTo(p.sx, p.sy);
          prevVisible = true;
        } else {
          prevVisible = false;
        }
      }
      ctx.closePath();
      ctx.fillStyle = 'rgba(18,42,68,0.65)';
      ctx.fill();

      // Draw border
      ctx.beginPath();
      started = false;
      prevVisible = false;
      for (let i = 0; i < pts.length; i++) {
        const p = project(pts[i][1], pts[i][0]);
        if (p.visible) {
          if (!started || !prevVisible) { ctx.moveTo(p.sx, p.sy); started = true; }
          else ctx.lineTo(p.sx, p.sy);
          prevVisible = true;
        } else {
          prevVisible = false;
        }
      }
      ctx.strokeStyle = 'rgba(55,120,180,0.35)';
      ctx.lineWidth = 0.6;
      ctx.stroke();
    });
  }

  ctx.restore(); // remove clip
}

function drawMarkers() {
  const filtered = SPORTS.filter(e => currentFilter === "all" || e.sport === currentFilter);
  const projected = filtered.map(e => ({ ...e, ...project(e.lat, e.lng) })).sort((a, b) => a.z - b.z);
  const zScale = Math.max(0.7, Math.min(2.8, zoom / 280));
  const showLabels = zoom > 320;

  projected.forEach(e => {
    if (!e.visible) return;
    const isLive = e.status === "LIVE";
    const isSel = e.id === selectedId;
    const baseR = isSel ? 9 : (isLive ? 7 : 5);
    const r = baseR * zScale;

    // Glow
    if (isLive) {
      const glow = ctx.createRadialGradient(e.sx, e.sy, 0, e.sx, e.sy, r * 3);
      glow.addColorStop(0, e.color + '30');
      glow.addColorStop(1, 'transparent');
      ctx.fillStyle = glow;
      ctx.fillRect(e.sx - r * 4, e.sy - r * 4, r * 8, r * 8);
    }

    // Pulse ring
    if (isLive) {
      const pr = r + 5 * zScale + Math.sin(pulseT * 2.5 + e.id) * 4 * zScale;
      const po = Math.max(0, 0.25 - Math.sin(pulseT * 2.5 + e.id) * 0.2);
      ctx.beginPath();
      ctx.arc(e.sx, e.sy, pr, 0, Math.PI * 2);
      ctx.strokeStyle = e.color + Math.round(po * 255).toString(16).padStart(2, '0');
      ctx.lineWidth = 1.5 * zScale;
      ctx.stroke();
    }

    // Beam
    if (isLive) {
      const beamH = (isSel ? 22 : 16) * zScale;
      ctx.beginPath();
      ctx.moveTo(e.sx, e.sy);
      ctx.lineTo(e.sx, e.sy - beamH);
      ctx.strokeStyle = e.color + '55';
      ctx.lineWidth = 1.5 * zScale;
      ctx.stroke();
    }

    // Dot
    ctx.beginPath();
    ctx.arc(e.sx, e.sy, r, 0, Math.PI * 2);
    ctx.fillStyle = isLive ? e.color : '#4B5563';
    ctx.fill();
    if (isSel) { ctx.strokeStyle = '#fff'; ctx.lineWidth = 2.5; ctx.stroke(); }
    else if (isLive) { ctx.strokeStyle = 'rgba(255,255,255,0.25)'; ctx.lineWidth = 1; ctx.stroke(); }

    // Icon
    const iconSize = Math.round((isSel ? 12 : 10) * zScale);
    ctx.font = `${iconSize}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(ICONS[e.sport] || '‚ö°', e.sx, e.sy);

    // Labels
    if (isSel || showLabels) {
      const labelY = e.sy - r - 6 * zScale - (isLive ? 10 * zScale : 0);
      const fs = Math.round(Math.max(8, Math.min(13, 9.5 * zScale)));
      const label = isSel ? `${e.home} vs ${e.away}` : e.city;
      ctx.font = `${isSel ? 'bold' : '600'} ${fs}px 'Space Grotesk', sans-serif`;
      const tw = ctx.measureText(label).width;
      const px = 7, py = 3;

      // Pill background
      const rx = e.sx - tw / 2 - px, ry = labelY - fs / 2 - py, rw = tw + px * 2, rh = fs + py * 2, rr = 5;
      ctx.fillStyle = isSel ? 'rgba(0,0,0,0.8)' : 'rgba(0,0,0,0.6)';
      ctx.beginPath();
      ctx.moveTo(rx + rr, ry); ctx.lineTo(rx + rw - rr, ry); ctx.quadraticCurveTo(rx + rw, ry, rx + rw, ry + rr);
      ctx.lineTo(rx + rw, ry + rh - rr); ctx.quadraticCurveTo(rx + rw, ry + rh, rx + rw - rr, ry + rh);
      ctx.lineTo(rx + rr, ry + rh); ctx.quadraticCurveTo(rx, ry + rh, rx, ry + rh - rr);
      ctx.lineTo(rx, ry + rr); ctx.quadraticCurveTo(rx, ry, rx + rr, ry);
      ctx.fill();

      ctx.fillStyle = isSel ? '#fff' : 'rgba(255,255,255,0.75)';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(label, e.sx, labelY);

      if (isSel && isLive) {
        ctx.font = `bold ${Math.round(fs * 0.8)}px 'JetBrains Mono', monospace`;
        ctx.fillStyle = e.color;
        ctx.fillText(`${e.score} ¬∑ ${e.detail}`, e.sx, labelY + fs + 3);
      }
    }
  });
}

// ‚Äî‚Äî‚Äî ANIMATION ‚Äî‚Äî‚Äî
function animate() {
  requestAnimationFrame(animate);
  pulseT += 0.03;
  rotX += (targetRotX - rotX) * 0.06;
  rotY += (targetRotY - rotY) * 0.06;
  zoom += (targetZoom - zoom) * 0.06;
  ctx.clearRect(0, 0, W, H);
  drawStars();
  drawGlobe();
  drawMarkers();
}

// ‚Äî‚Äî‚Äî INTERACTION ‚Äî‚Äî‚Äî
function handleClick(mx, my) {
  const filtered = SPORTS.filter(e => currentFilter === "all" || e.sport === currentFilter);
  let closest = null, closestDist = 20 * Math.max(1, zoom / 280);
  filtered.forEach(e => {
    const p = project(e.lat, e.lng);
    if (!p.visible) return;
    const d = Math.hypot(mx - p.sx, my - p.sy);
    if (d < closestDist) { closest = e; closestDist = d; }
  });
  if (closest) selectEvent(closest.id);
  else closeCard();
}

function selectEvent(id) {
  selectedId = id;
  const e = SPORTS.find(s => s.id === id);
  if (!e) return;
  targetRotY = -((e.lng + 90) * Math.PI / 180);
  targetRotX = (e.lat * Math.PI / 180) * 0.5;
  targetZoom = 420;
  showCard(e);
  updateTicker();
}

function showCard(e) {
  const isLive = e.status === "LIVE";
  const card = document.getElementById('card');
  card.style.borderTop = `2px solid ${e.color}`;
  document.getElementById('cardContent').innerHTML = `
    <div style="display:flex;align-items:center;gap:10px;margin-bottom:12px">
      <span style="font-size:28px">${ICONS[e.sport]}</span>
      <div>
        <div style="display:flex;align-items:center;gap:8px">
          <span style="color:${e.color};font-weight:700;font-size:11px;letter-spacing:1.5px;text-transform:uppercase;font-family:'JetBrains Mono',monospace">${e.league}</span>
          ${isLive ? '<span style="background:#EF4444;color:#fff;font-size:9px;font-weight:800;padding:2px 8px;border-radius:4px;letter-spacing:1px;animation:livePulse 1.5s infinite;font-family:monospace">LIVE</span>' : ''}
        </div>
        <div style="color:rgba(255,255,255,0.5);font-size:11px;font-family:'JetBrains Mono',monospace">${e.venue} ¬∑ ${e.city}, ${e.country}</div>
      </div>
    </div>
    <div style="display:flex;align-items:center;justify-content:center;gap:20px;margin:16px 0">
      <div style="text-align:center;flex:1;font-size:17px;font-weight:700">${e.home}</div>
      ${isLive ? `<div style="text-align:center"><div style="font-size:30px;font-weight:800;font-family:'JetBrains Mono',monospace;letter-spacing:2px">${e.score}</div><div style="color:${e.color};font-size:11px;font-weight:600;font-family:'JetBrains Mono',monospace">${e.detail} ¬∑ ${e.time}</div></div>` : `<div style="text-align:center"><div style="font-size:13px;color:rgba(255,255,255,0.4);font-family:monospace">STARTS</div><div style="font-size:22px;font-weight:700;font-family:monospace">${e.startTime}</div></div>`}
      <div style="text-align:center;flex:1;font-size:17px;font-weight:700">${e.away}</div>
    </div>
    ${e.viewers ? `<div style="text-align:center;color:rgba(255,255,255,0.35);font-size:11px;margin-bottom:16px;font-family:monospace">üëÅ ${e.viewers} watching</div>` : ''}
    ${isLive ? `<button class="stream-btn" style="background:linear-gradient(135deg,${e.color},${e.color}dd);box-shadow:0 4px 20px ${e.color}44" onclick="openStream(${e.id})">‚ñ∂ Watch Live Stream</button>` : ''}
  `;
  card.classList.add('open');
  cardOpen = true;
  document.getElementById('ticker').style.bottom = '255px';
  document.getElementById('zoom-controls').style.bottom = '280px';
}

function closeCard() {
  selectedId = null;
  document.getElementById('card').classList.remove('open');
  cardOpen = false;
  targetZoom = 280;
  document.getElementById('ticker').style.bottom = '14px';
  document.getElementById('zoom-controls').style.bottom = '80px';
  updateTicker();
}

function openStream(id) {
  const e = SPORTS.find(s => s.id === id);
  if (!e) return;
  document.getElementById('streamHeader').innerHTML = `
    <div style="display:flex;align-items:center;gap:10px">
      <span style="font-size:20px">${ICONS[e.sport]}</span>
      <div><div style="font-size:14px;font-weight:600">${e.home} vs ${e.away}</div><div style="color:rgba(255,255,255,0.5);font-size:11px;font-family:monospace">${e.league} ¬∑ ${e.score}</div></div>
    </div>
    <div style="display:flex;align-items:center;gap:12px">
      <span style="background:#EF4444;color:#fff;font-size:9px;font-weight:800;padding:3px 10px;border-radius:4px;letter-spacing:1px;font-family:monospace">‚óè LIVE</span>
      <button onclick="closeStream()" style="background:rgba(255,255,255,0.1);border:none;color:#fff;font-size:16px;cursor:pointer;border-radius:50%;width:32px;height:32px;display:flex;align-items:center;justify-content:center">‚úï</button>
    </div>`;
  document.getElementById('streamBody').innerHTML = `
    <div style="font-size:64px;margin-bottom:16px">${ICONS[e.sport]}</div>
    <div style="color:#fff;font-size:20px;font-weight:600;margin-bottom:8px">Stream Loading...</div>
    <div style="color:rgba(255,255,255,0.4);font-size:13px;font-family:monospace;max-width:320px">Prototype ‚Äî in production this embeds a live stream from the rights holder.</div>
    <div style="margin-top:24px;display:flex;gap:12px;justify-content:center;flex-wrap:wrap">
      ${["ESPN+","DAZN","Peacock","Paramount+"].map(s => `<span style="padding:8px 16px;border-radius:8px;background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.1);color:rgba(255,255,255,0.6);font-size:12px;font-family:monospace">${s}</span>`).join('')}
    </div>`;
  document.getElementById('stream-overlay').classList.add('open');
}
function closeStream() { document.getElementById('stream-overlay').classList.remove('open'); }

function buildFilters() {
  const el = document.getElementById('filters');
  el.innerHTML = FILTERS.map(f => `<button class="filter-btn ${f.k===currentFilter?'active':''}" data-filter="${f.k}"><span style="font-size:13px">${f.i}</span>${f.l}</button>`).join('');
  el.querySelectorAll('.filter-btn').forEach(btn => btn.addEventListener('click', () => { currentFilter = btn.dataset.filter; closeCard(); buildFilters(); updateTicker(); }));
}

function updateTicker() {
  const live = SPORTS.filter(e => e.status === "LIVE" && (currentFilter === "all" || e.sport === currentFilter));
  document.getElementById('ticker').innerHTML = live.map(e => `
    <div class="ticker-item ${e.id===selectedId?'selected':''}" style="--tc:${e.color}" onclick="selectEvent(${e.id})">
      <span style="font-size:15px">${ICONS[e.sport]}</span>
      <div><div style="font-size:10px;font-weight:600">${e.home} vs ${e.away}</div><div style="font-size:9px;font-family:monospace;font-weight:600;color:${e.color}">${e.score} ¬∑ ${e.time}</div></div>
    </div>`).join('');
}

function updateLiveCount() { document.getElementById('liveCount').textContent = SPORTS.filter(e=>e.status==="LIVE").length + ' LIVE'; }
function zoomIn() { targetZoom = Math.min(1800, targetZoom * 1.25); }
function zoomOut() { targetZoom = Math.max(150, targetZoom * 0.8); }

// ‚Äî‚Äî‚Äî INIT ‚Äî‚Äî‚Äî
function init() {
  canvas = document.getElementById('globe');
  ctx = canvas.getContext('2d');
  resize();
  window.addEventListener('resize', resize);

  canvas.addEventListener('mousedown', e => { dragging = true; dragDist = 0; lastMX = e.clientX; lastMY = e.clientY; canvas.classList.add('dragging'); });
  canvas.addEventListener('mousemove', e => { if (!dragging) return; const dx = e.clientX - lastMX, dy = e.clientY - lastMY; dragDist += Math.abs(dx) + Math.abs(dy); targetRotY += dx * 0.004; targetRotX += dy * 0.004; targetRotX = Math.max(-1.3, Math.min(1.3, targetRotX)); lastMX = e.clientX; lastMY = e.clientY; });
  canvas.addEventListener('mouseup', e => { canvas.classList.remove('dragging'); if (dragDist < 6) handleClick(e.clientX, e.clientY); dragging = false; });
  canvas.addEventListener('mouseleave', () => { dragging = false; canvas.classList.remove('dragging'); });
  canvas.addEventListener('wheel', e => { e.preventDefault(); targetZoom = Math.max(150, Math.min(1800, targetZoom - e.deltaY * 0.8)); }, { passive: false });

  canvas.addEventListener('touchstart', e => { e.preventDefault(); dragging = true; dragDist = 0; lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY; }, { passive: false });
  canvas.addEventListener('touchmove', e => { e.preventDefault(); if (!dragging) return; const dx = e.touches[0].clientX - lastMX, dy = e.touches[0].clientY - lastMY; dragDist += Math.abs(dx) + Math.abs(dy); targetRotY += dx * 0.004; targetRotX += dy * 0.004; targetRotX = Math.max(-1.3, Math.min(1.3, targetRotX)); lastMX = e.touches[0].clientX; lastMY = e.touches[0].clientY; }, { passive: false });
  canvas.addEventListener('touchend', e => { if (dragDist < 10) handleClick(e.changedTouches[0].clientX, e.changedTouches[0].clientY); dragging = false; });

  buildFilters();
  updateTicker();
  updateLiveCount();
  loadGeoData();
  animate();
  
  // Fetch live data immediately, then every 60 seconds
  fetchAllLive();
  setInterval(fetchAllLive, 60000);
}

function resize() {
  W = window.innerWidth; H = window.innerHeight;
  canvas.width = W * devicePixelRatio; canvas.height = H * devicePixelRatio;
  canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
  ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
}

init();
if ('serviceWorker' in navigator) navigator.serviceWorker.register('/sw.js').catch(()=>{});
</script>
</body>
</html>
